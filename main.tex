% filepath: c:\Users\j.noel\Desktop\EPHEC\devIII-tp\TP02\REPORT_TEMPLATE.tex
% Compiler: pdflatex REPORT_TEMPLATE.tex (ou xelatex)
\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{amssymb}

\geometry{margin=2.5cm}
\lstset{
  language=TypeScript,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  breaklines=true
}

\title{T2112 - Devoir 1 \\Rapport}
\author{Nom : Gregory Ly}

\begin{document}
\maketitle
\tableofcontents
\bigskip

\section*{Résumé}
J'ai finalisé la ressource \texttt{users} avec Express et Sequelize, en couvrant les opérations CRUD, la gestion des erreurs HTTP et une interface web minimale. Le frontend communique avec l'API via \texttt{fetch}, affiche les données, envoie les formulaires et montre les messages d'erreur/succès côté client.

\section{Objectifs (ce que je souhaite atteindre)}
\begin{enumerate}
  \item \textbf{API \& routes Express} : disposer des routes \texttt{GET /api/users}, \texttt{GET /api/users/:id}, \texttt{POST /api/users}, \texttt{PUT /api/users/:id}, \texttt{DELETE /api/users/:id}.
  \item \textbf{Base de données (Sequelize)} : utiliser correctement le modèle \texttt{User} et les opérations CRUD côté service dans \texttt{src/services/userServices.ts}.
  \item \textbf{Structure du code} : séparer la couche HTTP (\texttt{routes}) de la couche d'accès aux données (\texttt{services}).
  \item \textbf{Validation et erreurs HTTP} : valider les entrées (notamment \texttt{:id}) et renvoyer des statuts cohérents (\texttt{200}, \texttt{201}, \texttt{204}, \texttt{400}, \texttt{404}, \texttt{500}).
  \item \textbf{Interaction client \textless-\textgreater API} : créer une UI minimale (HTML + Bootstrap) et utiliser \texttt{fetch} pour consommer l'API avec affichage des erreurs/succès.
\end{enumerate}

\section{Stratégie et raisonnement}
J'ai conservé une séparation simple :
\begin{itemize}
  \item \texttt{userRoutes.ts} pour la couche HTTP ;
  \item \texttt{userServices.ts} pour les opérations Sequelize ;
  \item \texttt{public/index.html} et \texttt{public/script.js} pour la partie client.
\end{itemize}

Pour la gestion des erreurs, j'ai centralisé une logique homogène :
\begin{itemize}
  \item validation de l'ID dans les routes qui utilisent \texttt{:id} ;
  \item \texttt{404} quand la ressource n'existe pas ;
  \item \texttt{500} en cas d'exception ;
  \item affichage frontend des messages backend (\texttt{error}/\texttt{erreur}) avec un fallback.
\end{itemize}

\section{Réalisation (ce que j'ai réellement atteint et comment)}
\subsection{Backend API}
Les routes implémentées dans \texttt{src/routes/userRoutes.ts} :
\begin{itemize}
  \item \texttt{GET /api/users} : liste tous les utilisateurs ;
  \item \texttt{GET /api/users/:id} : récupère un utilisateur ;
  \item \texttt{POST /api/users} : crée un utilisateur ;
  \item \texttt{PUT /api/users/:id} : modifie un utilisateur ;
  \item \texttt{DELETE /api/users/:id} : supprime un utilisateur.
\end{itemize}

\subsection{Validation et réponses HTTP}
Exemple de validation d'entrée et de réponse d'erreur :
\begin{lstlisting}[caption=Validation ID et 404]
router.get('/:id', async (req: Request, res: Response) => {
  const id = Number(req.params.id);
  if (!Number.isInteger(id) || id <= 0) {
    return res.status(400).json({ error: 'ID invalide' });
  }

  const user = await findUserById(id);
  if (!user) {
    return res.status(404).json({ error: 'Pas de user ayant cet ID' });
  }

  return res.status(200).json(user);
});
\end{lstlisting}

\subsection{Services Sequelize}
La couche service reste simple et réutilisable :
\begin{itemize}
  \item \texttt{findAllUsers} ;
  \item \texttt{findUserById} ;
  \item \texttt{createUser} ;
  \item \texttt{updateUser} ;
  \item \texttt{deleteUser}.
\end{itemize}

\subsection{Frontend : interaction client \textless-\textgreater API}
La page \texttt{public/index.html} contient :
\begin{itemize}
  \item un formulaire d'ajout utilisateur ;
  \item une liste des utilisateurs ;
  \item une zone de message (\texttt{\#messageBox}).
\end{itemize}

Le fichier \texttt{public/script.js} gère :
\begin{itemize}
  \item \texttt{loadUsers()} pour \texttt{GET /api/users} ;
  \item \texttt{onFormSubmit()} pour \texttt{POST /api/users} ;
  \item \texttt{deleteUser(id)} pour \texttt{DELETE /api/users/:id} ;
  \item \texttt{showMessage()} / \texttt{clearMessage()} pour l'UI.
\end{itemize}

\begin{lstlisting}[caption=Recuperation des erreurs backend en frontend]
if (!response.ok) {
  const data = await response.json().catch(() => ({}));
  showMessage(data.error || data.erreur || 'Erreur pendant la creation');
  return;
}
\end{lstlisting}

\subsection{Statuts HTTP couverts}
\begin{itemize}
  \item \texttt{200} : lecture et mise a jour reussies ;
  \item \texttt{201} : creation reussie ;
  \item \texttt{204} : suppression reussie ;
  \item \texttt{400} : entree invalide (ex : ID invalide) ;
  \item \texttt{404} : ressource non trouvee ;
  \item \texttt{500} : erreur serveur.
\end{itemize}

\subsection{Preuves a joindre}
\label{sec:preuves}
Captures a inclure dans le dossier \texttt{screenshots/} :
\begin{itemize}
  \item test \texttt{GET /api/users} (200) ;
  \item test \texttt{GET /api/users/:id} invalide (400) ;
  \item test \texttt{GET /api/users/:id} introuvable (404) ;
  \item test \texttt{POST /api/users} (201) ;
  \item test \texttt{PUT /api/users/:id} (200) ;
  \item test \texttt{DELETE /api/users/:id} (204) ;
  \item capture frontend montrant un message d'erreur backend dans \texttt{\#messageBox}.
\end{itemize}

\section{Annexes}
\textit{Extraits des fichiers modifies dans ce devoir.}

\subsection{Annexe A - Route PUT}
\label{ann:routes-users}
Fichier : \texttt{src/routes/userRoutes.ts}
\begin{lstlisting}
router.put('/:id', async (req: Request, res: Response) => {
  try {
    const id = Number(req.params.id);
    if (!Number.isInteger(id) || id <= 0) {
      return res.status(400).json({ error: 'ID invalide' });
    }

    const { firstName, lastName } = req.body;
    const user = await updateUser(id, { firstName, lastName });
    if (!user) {
      return res.status(404).json({ error: 'Pas de user ayant cet ID' });
    }
    return res.status(200).json(user);
  } catch (error) {
    return res.status(500).json({ erreur: 'Erreur serveur' });
  }
});
\end{lstlisting}

\subsection{Annexe B - Frontend fetch}
\label{ann:frontend-fetch}
Fichier : \texttt{public/script.js}
\begin{lstlisting}
async function deleteUser(id) {
  clearMessage();
  const response = await fetch('/api/users/' + id, { method: 'DELETE' });

  if (!response.ok && response.status !== 204) {
    const data = await response.json().catch(() => ({}));
    showMessage(data.error || data.erreur || 'Erreur pendant la suppression');
    return;
  }

  showMessage('Utilisateur supprime', 'success');
  await loadUsers();
}
\end{lstlisting}

\subsection{Annexe C - Structure du projet}
\label{ann:structure}
\begin{itemize}
  \item \texttt{src/server.ts}
  \item \texttt{src/routes/userRoutes.ts}
  \item \texttt{src/services/userServices.ts}
  \item \texttt{public/index.html}
  \item \texttt{public/script.js}
\end{itemize}

\end{document}
